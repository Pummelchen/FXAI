#ifndef __FX6_AI_LSTMG_MQH__
#define __FX6_AI_LSTMG_MQH__

#include "..\plugin_base.mqh"

#define FX6_LSTMG_TBPTT 12

class CFX6AILSTMG : public CFX6AIPlugin
{
private:
   bool   m_initialized;
   int    m_step;
   int    m_seen_updates;

   double m_h[FX6_AI_MLP_HIDDEN];
   double m_c[FX6_AI_MLP_HIDDEN];

   double m_wi[FX6_AI_MLP_HIDDEN][FX6_AI_WEIGHTS];
   double m_wf[FX6_AI_MLP_HIDDEN][FX6_AI_WEIGHTS];
   double m_wo[FX6_AI_MLP_HIDDEN][FX6_AI_WEIGHTS];
   double m_wg[FX6_AI_MLP_HIDDEN][FX6_AI_WEIGHTS];

   double m_ui[FX6_AI_MLP_HIDDEN][FX6_AI_MLP_HIDDEN];
   double m_uf[FX6_AI_MLP_HIDDEN][FX6_AI_MLP_HIDDEN];
   double m_uo[FX6_AI_MLP_HIDDEN][FX6_AI_MLP_HIDDEN];
   double m_ug[FX6_AI_MLP_HIDDEN][FX6_AI_MLP_HIDDEN];

   // Peepholes.
   double m_pi[FX6_AI_MLP_HIDDEN];
   double m_pf[FX6_AI_MLP_HIDDEN];
   double m_po[FX6_AI_MLP_HIDDEN];

   double m_bi[FX6_AI_MLP_HIDDEN];
   double m_bf[FX6_AI_MLP_HIDDEN];
   double m_bo[FX6_AI_MLP_HIDDEN];
   double m_bg[FX6_AI_MLP_HIDDEN];

   double m_w_out[FX6_AI_MLP_HIDDEN];
   double m_b_out;
   double m_w_move[FX6_AI_MLP_HIDDEN];
   double m_b_move;

   // Sequence batching buffer for truncated BPTT.
   int    m_batch_size;
   double m_batch_h0[FX6_AI_MLP_HIDDEN];
   double m_batch_c0[FX6_AI_MLP_HIDDEN];
   double m_batch_x[FX6_LSTMG_TBPTT][FX6_AI_WEIGHTS];
   int    m_batch_y[FX6_LSTMG_TBPTT];
   double m_batch_move[FX6_LSTMG_TBPTT];
   double m_batch_w[FX6_LSTMG_TBPTT];

   void ResetState(void)
   {
      for(int h=0; h<FX6_AI_MLP_HIDDEN; h++)
      {
         m_h[h] = 0.0;
         m_c[h] = 0.0;
      }
   }

   void ResetBatch(void)
   {
      m_batch_size = 0;
      for(int h=0; h<FX6_AI_MLP_HIDDEN; h++)
      {
         m_batch_h0[h] = m_h[h];
         m_batch_c0[h] = m_c[h];
      }
   }

   void InitWeights(void)
   {
      for(int h=0; h<FX6_AI_MLP_HIDDEN; h++)
      {
         for(int i=0; i<FX6_AI_WEIGHTS; i++)
         {
            double s = (double)((h + 1) * (i + 7));
            m_wi[h][i] = 0.03 * MathSin(s * 0.71);
            m_wf[h][i] = 0.03 * MathCos(s * 0.73);
            m_wo[h][i] = 0.03 * MathSin(s * 0.79);
            m_wg[h][i] = 0.03 * MathCos(s * 0.83);
         }
         for(int j=0; j<FX6_AI_MLP_HIDDEN; j++)
         {
            double t = (double)((h + 3) * (j + 2));
            m_ui[h][j] = 0.02 * MathSin(t * 0.89);
            m_uf[h][j] = 0.02 * MathCos(t * 0.91);
            m_uo[h][j] = 0.02 * MathSin(t * 0.97);
            m_ug[h][j] = 0.02 * MathCos(t * 1.01);
         }

         m_pi[h] = 0.01 * MathSin((double)(h + 1) * 1.27);
         m_pf[h] = 0.01 * MathCos((double)(h + 1) * 1.31);
         m_po[h] = 0.01 * MathSin((double)(h + 1) * 1.37);

         m_bi[h] = 0.0;
         m_bf[h] = 0.2;
         m_bo[h] = 0.0;
         m_bg[h] = 0.0;

         m_w_out[h] = 0.03 * MathCos((double)(h + 1) * 1.41);
         m_w_move[h] = 0.03 * MathSin((double)(h + 1) * 1.11);
      }
      m_b_out = 0.0;
      m_b_move = 0.0;
      m_initialized = true;
   }

   double DotInput(const double &w[][FX6_AI_WEIGHTS], const int row, const double &x[]) const
   {
      double s = 0.0;
      for(int i=0; i<FX6_AI_WEIGHTS; i++) s += w[row][i] * x[i];
      return s;
   }

   double DotState(const double &u[][FX6_AI_MLP_HIDDEN], const int row, const double &hprev[]) const
   {
      double s = 0.0;
      for(int i=0; i<FX6_AI_MLP_HIDDEN; i++) s += u[row][i] * hprev[i];
      return s;
   }

   void ForwardOne(const double &x[],
                   const double &h_prev[],
                   const double &c_prev[],
                   double &ig[],
                   double &fg[],
                   double &og[],
                   double &gg[],
                   double &c_new[],
                   double &h_new[]) const
   {
      for(int h=0; h<FX6_AI_MLP_HIDDEN; h++)
      {
         ig[h] = FX6_Sigmoid(DotInput(m_wi, h, x) + DotState(m_ui, h, h_prev) + m_pi[h] * c_prev[h] + m_bi[h]);
         fg[h] = FX6_Sigmoid(DotInput(m_wf, h, x) + DotState(m_uf, h, h_prev) + m_pf[h] * c_prev[h] + m_bf[h]);
         gg[h] = FX6_Tanh(DotInput(m_wg, h, x) + DotState(m_ug, h, h_prev) + m_bg[h]);
         c_new[h] = fg[h] * c_prev[h] + ig[h] * gg[h];
         og[h] = FX6_Sigmoid(DotInput(m_wo, h, x) + DotState(m_uo, h, h_prev) + m_po[h] * c_new[h] + m_bo[h]);
         h_new[h] = og[h] * FX6_Tanh(c_new[h]);
      }
   }

   void AppendBatch(const int y,
                    const double &x[],
                    const double move_points,
                    const double sample_w)
   {
      if(m_batch_size <= 0)
      {
         for(int h=0; h<FX6_AI_MLP_HIDDEN; h++)
         {
            m_batch_h0[h] = m_h[h];
            m_batch_c0[h] = m_c[h];
         }
      }

      if(m_batch_size < FX6_LSTMG_TBPTT)
      {
         int p = m_batch_size;
         for(int i=0; i<FX6_AI_WEIGHTS; i++) m_batch_x[p][i] = x[i];
         m_batch_y[p] = y;
         m_batch_move[p] = move_points;
         m_batch_w[p] = sample_w;
         m_batch_size++;
         return;
      }

      // Keep latest TBPTT window if called before flush.
      for(int t=1; t<FX6_LSTMG_TBPTT; t++)
      {
         for(int i=0; i<FX6_AI_WEIGHTS; i++) m_batch_x[t - 1][i] = m_batch_x[t][i];
         m_batch_y[t - 1] = m_batch_y[t];
         m_batch_move[t - 1] = m_batch_move[t];
         m_batch_w[t - 1] = m_batch_w[t];
      }
      for(int i=0; i<FX6_AI_WEIGHTS; i++) m_batch_x[FX6_LSTMG_TBPTT - 1][i] = x[i];
      m_batch_y[FX6_LSTMG_TBPTT - 1] = y;
      m_batch_move[FX6_LSTMG_TBPTT - 1] = move_points;
      m_batch_w[FX6_LSTMG_TBPTT - 1] = sample_w;
      m_batch_size = FX6_LSTMG_TBPTT;
   }

   void TrainBatch(const FX6AIHyperParams &hp)
   {
      int len = m_batch_size;
      if(len <= 0) return;

      m_step += len;
      double lr0 = FX6_Clamp(hp.lr, 0.0001, 1.0000);
      double l2 = FX6_Clamp(hp.l2, 0.0000, 1.0000);
      double lr = lr0 / MathSqrt(1.0 + 0.001 * (double)m_step);

      double h_prev[FX6_LSTMG_TBPTT][FX6_AI_MLP_HIDDEN];
      double c_prev[FX6_LSTMG_TBPTT][FX6_AI_MLP_HIDDEN];
      double ig[FX6_LSTMG_TBPTT][FX6_AI_MLP_HIDDEN];
      double fg[FX6_LSTMG_TBPTT][FX6_AI_MLP_HIDDEN];
      double og[FX6_LSTMG_TBPTT][FX6_AI_MLP_HIDDEN];
      double gg[FX6_LSTMG_TBPTT][FX6_AI_MLP_HIDDEN];
      double c_t[FX6_LSTMG_TBPTT][FX6_AI_MLP_HIDDEN];
      double h_t[FX6_LSTMG_TBPTT][FX6_AI_MLP_HIDDEN];
      double p_raw[FX6_LSTMG_TBPTT];
      double pred_mv[FX6_LSTMG_TBPTT];

      double h_cur[FX6_AI_MLP_HIDDEN];
      double c_cur[FX6_AI_MLP_HIDDEN];
      for(int h=0; h<FX6_AI_MLP_HIDDEN; h++)
      {
         h_cur[h] = m_batch_h0[h];
         c_cur[h] = m_batch_c0[h];
      }

      // Forward unroll over sequence batch.
      for(int t=0; t<len; t++)
      {
         for(int h=0; h<FX6_AI_MLP_HIDDEN; h++)
         {
            h_prev[t][h] = h_cur[h];
            c_prev[t][h] = c_cur[h];
         }

         double xloc[FX6_AI_WEIGHTS];
         for(int i=0; i<FX6_AI_WEIGHTS; i++) xloc[i] = m_batch_x[t][i];

         double ig_loc[FX6_AI_MLP_HIDDEN];
         double fg_loc[FX6_AI_MLP_HIDDEN];
         double og_loc[FX6_AI_MLP_HIDDEN];
         double gg_loc[FX6_AI_MLP_HIDDEN];
         double c_new[FX6_AI_MLP_HIDDEN];
         double h_new[FX6_AI_MLP_HIDDEN];
         ForwardOne(xloc, h_cur, c_cur, ig_loc, fg_loc, og_loc, gg_loc, c_new, h_new);

         double z = m_b_out;
         double zm = m_b_move;
         for(int h=0; h<FX6_AI_MLP_HIDDEN; h++)
         {
            ig[t][h] = ig_loc[h];
            fg[t][h] = fg_loc[h];
            og[t][h] = og_loc[h];
            gg[t][h] = gg_loc[h];
            c_t[t][h] = c_new[h];
            h_t[t][h] = h_new[h];
            z += m_w_out[h] * h_new[h];
            zm += m_w_move[h] * h_new[h];
            h_cur[h] = h_new[h];
            c_cur[h] = c_new[h];
         }
         p_raw[t] = FX6_Sigmoid(z);
         pred_mv[t] = MathMax(0.0, zm);
      }

      // Keep latest recurrent state for next chunks.
      for(int h=0; h<FX6_AI_MLP_HIDDEN; h++)
      {
         m_h[h] = h_cur[h];
         m_c[h] = c_cur[h];
      }

      // Gradient accumulators.
      double g_wi[FX6_AI_MLP_HIDDEN][FX6_AI_WEIGHTS];
      double g_wf[FX6_AI_MLP_HIDDEN][FX6_AI_WEIGHTS];
      double g_wo[FX6_AI_MLP_HIDDEN][FX6_AI_WEIGHTS];
      double g_wg[FX6_AI_MLP_HIDDEN][FX6_AI_WEIGHTS];
      double g_ui[FX6_AI_MLP_HIDDEN][FX6_AI_MLP_HIDDEN];
      double g_uf[FX6_AI_MLP_HIDDEN][FX6_AI_MLP_HIDDEN];
      double g_uo[FX6_AI_MLP_HIDDEN][FX6_AI_MLP_HIDDEN];
      double g_ug[FX6_AI_MLP_HIDDEN][FX6_AI_MLP_HIDDEN];
      double g_pi[FX6_AI_MLP_HIDDEN];
      double g_pf[FX6_AI_MLP_HIDDEN];
      double g_po[FX6_AI_MLP_HIDDEN];
      double g_bi[FX6_AI_MLP_HIDDEN];
      double g_bf[FX6_AI_MLP_HIDDEN];
      double g_bo[FX6_AI_MLP_HIDDEN];
      double g_bg[FX6_AI_MLP_HIDDEN];
      double g_w_out[FX6_AI_MLP_HIDDEN];
      double g_w_move[FX6_AI_MLP_HIDDEN];
      double g_b_out = 0.0;
      double g_b_move = 0.0;

      for(int h=0; h<FX6_AI_MLP_HIDDEN; h++)
      {
         g_pi[h] = 0.0; g_pf[h] = 0.0; g_po[h] = 0.0;
         g_bi[h] = 0.0; g_bf[h] = 0.0; g_bo[h] = 0.0; g_bg[h] = 0.0;
         g_w_out[h] = 0.0; g_w_move[h] = 0.0;
         for(int i=0; i<FX6_AI_WEIGHTS; i++)
         {
            g_wi[h][i] = 0.0; g_wf[h][i] = 0.0; g_wo[h][i] = 0.0; g_wg[h][i] = 0.0;
         }
         for(int j=0; j<FX6_AI_MLP_HIDDEN; j++)
         {
            g_ui[h][j] = 0.0; g_uf[h][j] = 0.0; g_uo[h][j] = 0.0; g_ug[h][j] = 0.0;
         }
      }

      double dh_next[FX6_AI_MLP_HIDDEN];
      double dc_next[FX6_AI_MLP_HIDDEN];
      for(int h=0; h<FX6_AI_MLP_HIDDEN; h++)
      {
         dh_next[h] = 0.0;
         dc_next[h] = 0.0;
      }

      // Backward pass through truncated sequence.
      for(int t=len - 1; t>=0; t--)
      {
         double sw = FX6_Clamp(m_batch_w[t], 0.25, 4.00);
         double err_cls = FX6_ClipSym(((double)m_batch_y[t] - p_raw[t]) * sw, 3.0);
         double target_move = MathAbs(m_batch_move[t]);
         double err_mv = target_move - pred_mv[t];
         if(MathAbs(err_mv) > 10.0) err_mv = (err_mv > 0.0 ? 10.0 : -10.0);
         err_mv *= 0.12 * sw;

         g_b_out += err_cls;
         g_b_move += err_mv;

         double dh_prev[FX6_AI_MLP_HIDDEN];
         for(int j=0; j<FX6_AI_MLP_HIDDEN; j++) dh_prev[j] = 0.0;

         for(int h=0; h<FX6_AI_MLP_HIDDEN; h++)
         {
            g_w_out[h] += err_cls * h_t[t][h];
            g_w_move[h] += err_mv * h_t[t][h];

            double tanh_c = FX6_Tanh(c_t[t][h]);
            double dh = dh_next[h] + err_cls * m_w_out[h] + 0.40 * err_mv * m_w_move[h];

            double dzo = (dh * tanh_c) * og[t][h] * (1.0 - og[t][h]);
            double dc = dc_next[h] + dh * og[t][h] * (1.0 - tanh_c * tanh_c) + dzo * m_po[h];
            double dzi = (dc * gg[t][h]) * ig[t][h] * (1.0 - ig[t][h]);
            double dzf = (dc * c_prev[t][h]) * fg[t][h] * (1.0 - fg[t][h]);
            double dzg = (dc * ig[t][h]) * (1.0 - gg[t][h] * gg[t][h]);
            double dc_prev = dc * fg[t][h] + dzi * m_pi[h] + dzf * m_pf[h];

            // Peephole gradients with proper cell source terms.
            g_pi[h] += dzi * c_prev[t][h];
            g_pf[h] += dzf * c_prev[t][h];
            g_po[h] += dzo * c_t[t][h];

            g_bi[h] += dzi;
            g_bf[h] += dzf;
            g_bo[h] += dzo;
            g_bg[h] += dzg;

            for(int i=0; i<FX6_AI_WEIGHTS; i++)
            {
               double xv = m_batch_x[t][i];
               g_wi[h][i] += dzi * xv;
               g_wf[h][i] += dzf * xv;
               g_wo[h][i] += dzo * xv;
               g_wg[h][i] += dzg * xv;
            }

            for(int j=0; j<FX6_AI_MLP_HIDDEN; j++)
            {
               double hpv = h_prev[t][j];
               g_ui[h][j] += dzi * hpv;
               g_uf[h][j] += dzf * hpv;
               g_uo[h][j] += dzo * hpv;
               g_ug[h][j] += dzg * hpv;

               dh_prev[j] += m_ui[h][j] * dzi +
                             m_uf[h][j] * dzf +
                             m_uo[h][j] * dzo +
                             m_ug[h][j] * dzg;
            }

            dc_next[h] = dc_prev;
         }

         for(int j=0; j<FX6_AI_MLP_HIDDEN; j++)
            dh_next[j] = dh_prev[j];
      }

      // Global gradient norm clipping.
      double gnorm2 = g_b_out * g_b_out + g_b_move * g_b_move;
      for(int h=0; h<FX6_AI_MLP_HIDDEN; h++)
      {
         gnorm2 += g_pi[h] * g_pi[h] + g_pf[h] * g_pf[h] + g_po[h] * g_po[h];
         gnorm2 += g_bi[h] * g_bi[h] + g_bf[h] * g_bf[h] + g_bo[h] * g_bo[h] + g_bg[h] * g_bg[h];
         gnorm2 += g_w_out[h] * g_w_out[h] + g_w_move[h] * g_w_move[h];
         for(int i=0; i<FX6_AI_WEIGHTS; i++)
         {
            gnorm2 += g_wi[h][i] * g_wi[h][i] + g_wf[h][i] * g_wf[h][i] +
                      g_wo[h][i] * g_wo[h][i] + g_wg[h][i] * g_wg[h][i];
         }
         for(int j=0; j<FX6_AI_MLP_HIDDEN; j++)
         {
            gnorm2 += g_ui[h][j] * g_ui[h][j] + g_uf[h][j] * g_uf[h][j] +
                      g_uo[h][j] * g_uo[h][j] + g_ug[h][j] * g_ug[h][j];
         }
      }

      double gnorm = MathSqrt(gnorm2);
      double gscale = (gnorm > 5.0 ? (5.0 / gnorm) : 1.0);

      // Parameter update.
      m_b_out += lr * gscale * g_b_out;
      m_b_move += lr * gscale * g_b_move;
      for(int h=0; h<FX6_AI_MLP_HIDDEN; h++)
      {
         m_w_out[h] += lr * (gscale * g_w_out[h] - l2 * m_w_out[h]);
         m_w_move[h] += lr * (gscale * g_w_move[h] - l2 * m_w_move[h]);

         m_pi[h] += lr * (gscale * g_pi[h] - l2 * m_pi[h]);
         m_pf[h] += lr * (gscale * g_pf[h] - l2 * m_pf[h]);
         m_po[h] += lr * (gscale * g_po[h] - l2 * m_po[h]);

         m_bi[h] += lr * gscale * g_bi[h];
         m_bf[h] += lr * gscale * g_bf[h];
         m_bo[h] += lr * gscale * g_bo[h];
         m_bg[h] += lr * gscale * g_bg[h];

         for(int i=0; i<FX6_AI_WEIGHTS; i++)
         {
            m_wi[h][i] += lr * (gscale * g_wi[h][i] - l2 * m_wi[h][i]);
            m_wf[h][i] += lr * (gscale * g_wf[h][i] - l2 * m_wf[h][i]);
            m_wo[h][i] += lr * (gscale * g_wo[h][i] - l2 * m_wo[h][i]);
            m_wg[h][i] += lr * (gscale * g_wg[h][i] - l2 * m_wg[h][i]);
         }

         for(int j=0; j<FX6_AI_MLP_HIDDEN; j++)
         {
            m_ui[h][j] += lr * (gscale * g_ui[h][j] - l2 * m_ui[h][j]);
            m_uf[h][j] += lr * (gscale * g_uf[h][j] - l2 * m_uf[h][j]);
            m_uo[h][j] += lr * (gscale * g_uo[h][j] - l2 * m_uo[h][j]);
            m_ug[h][j] += lr * (gscale * g_ug[h][j] - l2 * m_ug[h][j]);
         }
      }

      // Calibration and move-head updates per sample.
      for(int t=0; t<len; t++)
      {
         double sw = FX6_Clamp(m_batch_w[t], 0.25, 4.00);
         UpdateCalibration(p_raw[t], m_batch_y[t], sw);
         FX6_UpdateMoveEMA(m_move_ema_abs, m_move_ready, m_batch_move[t], 0.05);
         double xloc[FX6_AI_WEIGHTS];
         for(int i=0; i<FX6_AI_WEIGHTS; i++) xloc[i] = m_batch_x[t][i];
         UpdateMoveHead(xloc, m_batch_move[t], hp, sw);
      }

      ResetBatch();
   }

public:
   CFX6AILSTMG(void) { Reset(); }

   virtual int AIId(void) const { return (int)AI_TYPE_LSTMG; }
   virtual string AIName(void) const { return "lstmg"; }

   virtual void Reset(void)
   {
      CFX6AIPlugin::Reset();
      m_initialized = false;
      m_step = 0;
      m_seen_updates = 0;
      ResetState();
      ResetBatch();
   }

   virtual void EnsureInitialized(const FX6AIHyperParams &hp)
   {
      if(!m_initialized) InitWeights();
   }

   virtual void Update(const int y, const double &x[], const FX6AIHyperParams &hp)
   {
      double pseudo_move = (y == 1 ? 1.0 : -1.0);
      UpdateWithMove(y, x, hp, pseudo_move);
   }

   virtual void UpdateWithMove(const int y,
                               const double &x[],
                               const FX6AIHyperParams &hp,
                               const double move_points)
   {
      EnsureInitialized(hp);
      m_seen_updates++;

      int cls = NormalizeClassLabel(y, x, move_points);
      if(cls == (int)FX6_LABEL_SKIP) return;
      int y_dir = (cls == (int)FX6_LABEL_BUY ? 1 : 0);
      double cls_w = 1.0;

      // Controlled reset policy to prevent hidden-state bleed.
      if((m_seen_updates % 512) == 0 ||
         MathAbs(x[1]) > 7.5 || MathAbs(x[2]) > 7.5)
      {
         ResetState();
         ResetBatch();
      }

      FX6AIHyperParams h = ScaleHyperParamsForMove(hp, move_points);
      double w = FX6_Clamp(MoveSampleWeight(x, move_points) * cls_w, 0.10, 4.00);
      AppendBatch(y_dir, x, move_points, w);

      if(m_batch_size >= FX6_LSTMG_TBPTT)
         TrainBatch(h);
   }

   virtual double PredictProb(const double &x[], const FX6AIHyperParams &hp)
   {
      EnsureInitialized(hp);

      double ig[FX6_AI_MLP_HIDDEN];
      double fg[FX6_AI_MLP_HIDDEN];
      double og[FX6_AI_MLP_HIDDEN];
      double gg[FX6_AI_MLP_HIDDEN];
      double c_new[FX6_AI_MLP_HIDDEN];
      double h_new[FX6_AI_MLP_HIDDEN];
      ForwardOne(x, m_h, m_c, ig, fg, og, gg, c_new, h_new);

      double z = m_b_out;
      for(int h=0; h<FX6_AI_MLP_HIDDEN; h++)
         z += m_w_out[h] * h_new[h];

      double p_raw = FX6_Sigmoid(z);
      return CalibrateProb(p_raw);
   }

   virtual double PredictExpectedMovePoints(const double &x[], const FX6AIHyperParams &hp)
   {
      EnsureInitialized(hp);

      double ig[FX6_AI_MLP_HIDDEN];
      double fg[FX6_AI_MLP_HIDDEN];
      double og[FX6_AI_MLP_HIDDEN];
      double gg[FX6_AI_MLP_HIDDEN];
      double c_new[FX6_AI_MLP_HIDDEN];
      double h_new[FX6_AI_MLP_HIDDEN];
      ForwardOne(x, m_h, m_c, ig, fg, og, gg, c_new, h_new);

      double zm = m_b_move;
      for(int h=0; h<FX6_AI_MLP_HIDDEN; h++)
         zm += m_w_move[h] * h_new[h];

      double p = MathMax(0.0, zm);
      if(p > 0.0 && m_move_ready && m_move_ema_abs > 0.0)
         return 0.70 * p + 0.30 * m_move_ema_abs;
      if(p > 0.0) return p;
      return CFX6AIPlugin::PredictExpectedMovePoints(x, hp);
   }
};

#endif // __FX6_AI_LSTMG_MQH__
